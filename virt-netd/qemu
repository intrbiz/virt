#!/usr/bin/perl
use 5.010;
use XML::Simple;
use JSON;
use Data::Dumper;

##
## Config - TODO
##
$vxlan_group = '239.1.1.1';
$vxlan_port  = '4789';
$interconnect_interface = 'enp0s31f6';

##
## Low-level execution handling for iproute2 `ip` command
##
sub ip
{
    my ($log, $command) = @_;
    my $full_command = 'ip -j -d ' . $command . ' 2>/dev/null';
    #print $log "Executing ${full_command}\n";
    my $out  = qx($full_command);
    my $exit = $?;
    #print $log "Executed ip, exit: $exit, stdout: '$out'\n";
    my $data = (length($out) > 0) ? from_json($out) : {};
    return {
        'exit' => $exit,
        'data' => $data
    };
}

##
## List links of this system
##
sub list_links
{
    my ($log) = @_;
    my $data = ip($log, 'link show');
    return $data->{'data'};
}

##
## List the VXLAN tunnels of this system
##
sub list_vxlan_tunnels
{
    my ($log) = @_;
    my $data = ip($log, 'link show type vxlan');
    return $data->{'data'};
}

##
## List the bridges of this system
##
sub list_bridges
{
    my ($log) = @_;
    my $data = ip($log, 'link show type bridge');
    return $data->{'data'};
}

##
## Get a link from the given list of links with the given name and optionally of the given type
##
sub get_link
{
    my ($data, $name, $kind) = @_;
    foreach my $link (@{$data})
    {
        if ($link->{'ifname'} eq $name && ((! defined $kind) || $link->{'linkinfo'}->{'info_kind'} eq $kind))
        {
            return $link;
        }
    }
    return undef;
}

##
## Get all links from the given list of links which are in the given bridge
##
sub get_links_in_bridge
{
    my ($data, $bridge_name) = @_;
    my $links = [];
    foreach my $link (@{$data})
    {
        if ($link->{'master'} eq $bridge_name)
        {
            push(@{$links}, $link);
        }
    }
    return $links;
}

##
## Get a bridge from the given list of links with the given name
##
sub get_bridge
{
    my ($data, $name) = @_;
    return get_link($data, $name, 'bridge');
}

##
## Does a bridge exists with in the given list of links with the given name
##
sub has_bridge
{
    my ($data, $name) = @_;
    return defined get_bridge($data, $name);
}

##
## Get a VXLAN tunnel from the given list of links with the given name
##
sub get_vxlan_tunnel
{
    my ($data, $name) = @_;
    return get_link($data, $name, 'vxlan');
}

##
## Does a VXLAN tunnel exist with in the given list of links with the given name
##
sub has_vxlan_tunnel
{
    my ($data, $name) = @_;
    return defined get_vxlan($data, $name);
}

##
## Construct the name for a bridge for the given network id
##
sub bridge_name
{
    my ($network_id) = @_;
    return sprintf('br-%x', $network_id);
}

##
## Extract the network id from the given bridge name
##
sub from_bridge_name
{
    my ($bridge_name) = @_;
    return hex(substr($bridge_name, 3));
}

##
## Construct the name for a VXLAN tunnel for the given network id
##
sub vxlan_name
{
    my ($network_id) = @_;
    return sprintf('vx-%x', $network_id);
}

##
## Extract the network id from the given VXLAN tunnel name
##
sub from_vxlan_name
{
    my ($vxlan_name) = @_;
    return hex(substr($vxlan_name, 3));
}

##
## Create a bridge for the given network id
##
sub create_bridge
{
    my ($log, $network_id) = @_;
    my $bridge_name = bridge_name($network_id);
    my $link = get_bridge(list_bridges($log), $bridge_name);
    if (! defined $link)
    {
        print $log "Creating bridge for network $network_id\n";
        ip($log, "link add name ${bridge_name} type bridge");
    }
    if (! (defined $link && $link->{'operstate'} eq 'UP'))
    {
        print $log "Bringing up bridge for network $network_id\n";
        ip($log, "link set dev ${bridge_name} up");
    }
    return $bridge_name;
}

##
## Create a VXLAN tunnel for the given network id
##
sub create_vxlan_tunnel
{
    my ($log, $network_id) = @_;
    my $tunnel_name = vxlan_name($network_id);
    my $link = get_vxlan_tunnel(list_vxlan_tunnels($log), $tunnel_name);
    if (! defined $link)
    {
        print $log "Creating VXLAN tunnel for network $network_id\n";
        ip($log, "link add ${tunnel_name} type vxlan id ${network_id} group ${vxlan_group} dev ${interconnect_interface} dstport ${vxlan_port}");
    }
    if (! (defined $link && $link->{'operstate'} eq 'UP'))
    {
        print $log "Bringing up VXLAN tunnel for network $network_id\n";
        ip($log, "link set dev ${tunnel_name} up");
    }
    return $tunnel_name;
}

##
## Place the given interface into the given bridge
##
sub place_in_bridge
{
    my ($log, $bridge_name, $interface_name) = @_;
    my $link = get_link(list_links($log), $interface_name);
    if (! (defined $link && $link->{'master'} eq $bridge_name))
    {
        print $log "Placing interface $interface_name into bridge $bridge_name\n";
        ip($log, "link set dev ${interface_name} master ${bridge_name}");
    }
}

##
## Remove the link of the given name
##
sub remove_link
{
    my ($log, $interface_name) = @_;
    print $log "Removing link $interface_name\n";
    ip($log, "link del dev $interface_name");
}

##
## Create a virtual network, ensuring that a VXLAN tunnel and bridge is created for the given network id
##
sub create_virtual_network
{
    my ($log, $network_id) = @_;
    my $tunnel = create_vxlan_tunnel($log, $network_id);
    my $bridge = create_bridge($log, $network_id);
    place_in_bridge($log, $bridge, $tunnel);
    return $bridge;
}

##
## Release a virtual network, removing the VXLAN tunnel and bridge if the network is no longer in use
##
sub release_virtual_network
{
    my ($log, $network_id) = @_;
    my $tunnel_name = vxlan_name($network_id);
    my $bridge_name = bridge_name($network_id);
    my $links_in_bridge = get_links_in_bridge(list_links($log), $bridge_name);
    if (scalar(@{$links_in_bridge}) == 0 || (scalar(@{$links_in_bridge}) == 1 && $links_in_bridge->[0]->{'ifname'} eq $tunnel_name))
    {
        print $log "No VMs connected to network $network_id, releasing network\n";
        remove_link($log, $bridge_name);
        remove_link($log, $tunnel_name);
    }
}

##
## Hook Handling
##

##
## Read the hook event data for this process
##
sub read_hook_event
{
    my ($log) = @_;
    my $xs     = XML::Simple->new();
    my $domain = $xs->XMLin('-');
    return {
        'object'        => shift(@ARGV),
        'operation'     => shift(@ARGV),
        'sub_operation' => shift(@ARGV),
        'extra'         => shift(@ARGV),
        'domain'        => $domain,
        'uuid'          => $domain->{'uuid'}
    };
}

##
## Process the libvirtd qemu prepare hook
##
sub process_prepare
{
    my ($log, $event) = @_;
    # Create all bridges
    my $ifindex = 0;
    foreach my $interface (@{$event->{'domain'}->{'devices'}->{'interface'}})
    {
        print $log "Preparing interface: eth$ifindex\n";
        if ($interface->{'type'} eq 'bridge')
        {
            my $network_id  = from_bridge_name($interface->{'source'}->{'bridge'});
            print $log "Preparing network $network_id\n";
            create_virtual_network($log, $network_id);
        }
        $ifindex++;
    }
}

##
## Process the libvirtd qemu migrate hook
##
sub process_migrate
{
    my ($log, $event) = @_;
    ## Prepare the resources needed
    process_prepare($log, $event);
}

##
## Process the libvirtd qemu release hook
##
sub process_release
{
    my ($log, $event) = @_;
    # Create all bridges
    my $ifindex = 0;
    foreach my $interface (@{$event->{'domain'}->{'devices'}->{'interface'}})
    {
        print $log "Releasing interface: eth$ifindex\n";
        if ($interface->{'type'} eq 'bridge')
        {
            my $network_id  = from_bridge_name($interface->{'source'}->{'bridge'});
            print $log "Releasing network $network_id\n";
            release_virtual_network($log, $network_id);
        }
        $ifindex++;
    }
}

##
## Process a libvirtd qemu hook
##
sub process
{
    my ($log, $event) = @_;
    print $log "Processing hook ", $event->{'operation'}, " ", $event->{'uuid'}, "\n";
    if ($event->{'operation'} eq 'prepare')
    {
        process_prepare($log, $event);
    }
    elsif ($event->{'operation'} eq 'migrate')
    {
        process_migrate($log, $event);
    }
    elsif ($event->{'operation'} eq 'release')
    {
        process_release($log, $event);
    }
    print $log "Finished hook\n";
}

# Execute this hook
open(my $log, '>>', '/var/log/virt-netd-hook.log');
my $event = read_hook_event($log);
process($log, $event);
close $log;
